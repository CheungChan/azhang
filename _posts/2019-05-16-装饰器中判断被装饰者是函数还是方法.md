---
title: 装饰器中判断被装饰者是函数还是方法
layout: post
date: '2019-05-16 16:00:00'
categories: 技术 装饰器  导入时 运行时 缓存 cache python python_common_tools
---

### 问题
最近碰到一个场景, 我希望把一个方法的执行结果缓存起来, 按天缓存. 当天如果执行过这个方法, 直接返回, 明天重新跑.
这是一个普遍性的需求而且是纯技术问题, 应该好多项目可以用到.所以我写了一个开源库python_common_tools, 可以通过<code>pip install python_common_tools</code>来安装(支持python3.6+). 但是今天使用的时候遇到一个问题.

调用python_common_tools.cache.cache_daily_function的时候, 被装饰者是一个method. 发现每次程序终止的时候, 再启动不会使用之前创建的缓存. 代码库如下

```python
# -*- coding: utf-8 -*-
__author__ = '陈章'
__date__ = '2019-04-25 11:34'
import os
import pickle
from datetime import datetime
from functools import wraps
from inspect import ismethod
from urllib.parse import quote_plus

from logzero import logger

from python_common_tools.compress import get_md5


class Cache:

    @classmethod
    def cache_function(cls, cache_dir):
        def outer(f):
            @wraps(f)
            def inner(*args, **kwargs):
                # prepare cache_file
                fname = f.__qualname__
                no_self_args = args[1:] if ismethod(f) else args
                argv_str = f'{quote_plus(str(no_self_args))}_{quote_plus(str(kwargs))}'
                cache_dir_real = f'{cache_dir}/{fname}'
                os.makedirs(cache_dir_real, exist_ok=True)
                cache_file = f'{cache_dir_real}/{get_md5(argv_str)}.pkl'

                # exec func
                if not os.path.exists(cache_file):
                    logger.debug(f'exec func {fname} {args} {kwargs}')
                    r = f(*args, **kwargs)
                    cls.write_to_cache_file(cache_file, r)
                r = cls.read_from_cache_file(cache_file)
                return r

            return inner

        return outer

    @classmethod
    def cache_daily_function(cls, cache_dir):
        def outer(f):
            @wraps(f)
            def inner(*args, **kwargs):
                # prepare cache file
                fname = f.__qualname__
                no_self_args = args[1:] if ismethod(f) else args
                today = datetime.now().strftime("%Y%m%d")
                argv_str = f'{quote_plus(str(no_self_args))}_{quote_plus(str(kwargs))}'
                cache_dir_real = f'{cache_dir}/{fname}/{today}'
                os.makedirs(cache_dir_real, exist_ok=True)
                cache_file = f'{cache_dir_real}/{get_md5(argv_str)}.pkl'

                # exec func
                if not os.path.exists(cache_file):
                    logger.debug(f'exec func {fname} {no_self_args} {kwargs}')
                    r = f(*args, **kwargs)
                    cls.write_to_cache_file(cache_file, r)
                r = cls.read_from_cache_file(cache_file)
                return r

            return inner

        return outer

    @classmethod
    def read_from_cache_file(cls, cache_file):
        r_cache_file = open(cache_file, 'rb')
        r = pickle.load(r_cache_file)
        r_cache_file.close()
        return r

    @classmethod
    def write_to_cache_file(cls, cache_file, r):
        w_cache_file = open(cache_file, 'wb')
        pickle.dump(r, w_cache_file)
        w_cache_file.close()


cache_function = Cache.cache_function
cache_daily_function = Cache.cache_daily_function

```
在判断被装饰者是函数还是方法 的时候, 使用的inspect.ismethod(f). 

调用部分代码如下
```python
import time

from python_common_tools.cache import cache_daily_function


class C:
    @cache_daily_function("./cache")
    def f(self, a, b, c):
        time.sleep(3)
        return a + b + c

    def main(self):
        a = 1
        b = 1
        c = 1
        r = self.f(a, b, c)
        print(r)
        r2 = self.f(a, b, c)
        print(r2)


if __name__ == '__main__':
    C().main()

```
很明显调用的C.f函数是一个方法, 但是debug发现在装饰器里面inspect.ismethod(f)返回的是False.

### 查找资料
经过一番调研之后,  找到了inspect的官方文档   [https://docs.python.org/3/library/inspect.html](https://docs.python.org/3/library/inspect.html)  发现ismethod的解释是这样的
> Return true if the object is a bound method written in Python.

也就是说当对象是绑定方法的时候, 才返回True. 那么什么时候这个对象可以被称为绑定方法了呢?

在python3里面函数和方法的区别只有一个是否绑定了一个类对象. 体现在参数传递里方法会隐式的把绑定的对象作为第一
个参数传递进去. 

那么在这个场景里面. 装饰器的实质只是一层参数调用. 将C.f 传递到了装饰器里面. 此时python的运行时环境是导入时, 而不是运行时. 或者说处于解释器执行函数(这里是方法)定义的时候. 此时打印<code>f.__qualname__</code> 显示的是<code>C.f</code> . 也就是再尚未执行f之前, f都处于未绑定到特定对象上的状态. 在运行时, f才被绑定到了C创建的对象上面.

尝试着在运行时调用一下inspect.ismethod(f)

```python
import time
import inspect

from python_common_tools.cache import cache_daily_function


class C:
    @cache_daily_function("./cache")
    def f(self, a, b, c):
        time.sleep(3)
        return a + b + c


    def main(self):
        a = 1
        b = 1
        c = 1
        r = self.f(a, b, c)
        print(r)
        r2 = self.f(a, b, c)
        print(r2)


if __name__ == '__main__':
    # C().main()
    print(inspect.ismethod(C().f))   # 输出为True

```

那不能用这个方法怎么办? 

回到方法和函数的根本区别上面. 我们可以判断args的第0个元素是不是self就行了. 也就是判断这个参数是不是类创建的对象就哦了.

### 进一步找到答案
所以我们就去想如何判断一个对象是不是类创建的对象. 自然可以想起类默认是由元类type创建的. 那么调用<code>type(C())</code>会返回<code><class '__main__.C'></code>然后判断它是一个类就可以了. 可以使用<code>inspect.isclass</code>来判断


### 最终解决方案
```python
no_self_args = args[1:] if len(args) > 0 and inspect.isclass(type(args[0])) else args
```
现python_common_tools已更新到1.0.14版本. 修复了这个问题.