---
title: 总结asyncio
key: sumarry_asyncio
layout: article
date: '2019-05-29 16:20:00'
tags: 技术 总结 python 
typora-root-url: ../../iblog
---

## 参考链接

[深入理解ASYNCIO（一）](https://mp.weixin.qq.com/s/kxWmO6Q_VYt749OhAoTEUA)

[深入理解ASYNCIO（二）](https://mp.weixin.qq.com/s/B9ZAazfXEtAPtptewhWteQ)

## 总结

总结一下 py3.7新增的asyncio.run方法你应该尽量用新的，Future是对协程的封装，但是太底层，你应该尽量用其子类Task。await之后Future对象状态才会变成finished，一个对象可以被await是因为它的类实现了__await__方法，为什么await了之后状态就改变了呢，是因为在loop.run_in_executor里面注册了一个_call_set_state回调，task可以通过ensure_future或者create_task轻松的创建。并不是用了async.await你就用对了asyncio的并发了，事实上你应该用gather或者wait将他们攒在一起才能真正并发，另外需要注意不是直接await task就完了，要把task赋值给一个局部变量以后再await才能实现真正并发。

接上一篇，asyncio的gather和wait方法有什么区别呢？gather方法会根据传入的协程的顺序搜集到执行结果，以一个元祖的形式返回执行结果。而wait是返回完成的task集合和挂起的task集合，另外支持通过关键字参数return_when来指定返回的时机，默认是ALLCOMPLETED，还支持FIRSTCOMPLETED和FIRSTEXCEPTION，如果业务上需要这两种状态下返回或者随时取消任务，添加回调就可以调用wait方法。create_task参数要求是协程来创建Task对象，而ensure_future可以接受协程或者Future对象或者awaitable对象，ensure_future源码实际上如果传入协程，直接调用create_task来返回Task对象，如果传入Future对象，直接返回，如果传入awaitable对象，则先await一下这个对象，然后再次调用ensure_future方法，返回Task对象或者Future对象。而wait和gather方法里面都调用了ensure_future。绝大多数场景并发的都是协程，所以用create_task就够了。利用asyncio.shield可以屏蔽取消操作，如果任务取消了，直接调用gather会触发CanceledError异常，如果传入关键字参数return_exceptions=True不会触发异常，而是返回值在取消的那个协程对应的位置是CanceledError异常实例。利用shield保护不被取消要注意顺序必须是先gather协程赋值给一个变量（GatheringFuture对象），然后取消任务，然后再await这个变量。另外，py3.7新增了asynccontextmanager可以使用async with调用，异步装饰器内部调用函数可以用yield await func()