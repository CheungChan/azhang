---
title: xadmin使用Q&A
key: xadmin_qa
layout: article
date: '2019-07-18 12:51:00'
tags: 技术 python
typora-root-url: ../../iblog
---

### Q: 如何在一个model的新增或编辑页面里面内嵌另一个model的编辑页面

### A:

1. 定义一个Inline类
2. 在model的OptionClass里面讲Inline类注入到inlines属性里面

举例:

在IOC这个model里面内嵌了两个一对多的model. IOC和FileAttachment

**xadmin.py**

```python
from .models import Case, Ioc, FileAttachment
class IocInline:
    model = Ioc
    extra = 0

class FileAttachmentInline:
    model = FileAttachment
    extra = 0

class CaseForm(ModelForm):
  # 自定义widgets
    tags = SimpleArrayField(CharField(), widget=Select2Widget, required=False)
    
class CaseAdmin:
    list_display = ["name", "happen_datetime", "TLP", "tags", "len_ioc", "len_file", "update_user", "update_time"]
    search_fields = ["name", "TLP", "tags", "update_user"]
    list_filter = ["name", "happen_datetime", "TLP", "update_user", "update_time"]
    # 因为自定义了widgets 所以设置了form属性
    form = CaseForm

    # 在同一编辑界面,内联IOC编辑
    inlines = [IocInline, FileAttachmentInline]
    list_export = []
```

效果图: 

点击+ 即可新增多个

![](http://img.azhangbaobao.cn/img/20190718132851.png)

### Q: 如何使用一个数据库表, 但是使用多个xadmin页面

### A:

1. 搞清楚为什么有这样的需求, 原因是django的权限系统只能针对表级别的增删改查做. 但是实际开发中, 会出现一种需求, 都是一个model表, 但是里面有个类型字段不同, 操作的权限因而不同. 这就需要五个页面. 但是每个页面的查询实际上是model查询根据类型过滤之后的结果
2. django的model里面有个model proxy. 可以实现这一需求, model proxy不落实到数据库, 但是继承落实到数据库里的model. 实际上增删改查操作继承的model
3. 每个model proxy再定义自己的OptionClass
4. 将model proxy和 OptionClass注册到xadmin
5. 做makemigrations的时候django<2.2的时候有个bug. 就是model proxy生成的权限的Content Type不是model proxy, 而是继承的model的. 需要编写自定义command来修复这个bug.

举例:

```python
from .models import Case



## 定义了5个model proxy
class TuanHuoFenXi(Case):
    class Meta:
        proxy = True
        verbose_name = "团伙分析报告"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


class AnYuan(Case):
    class Meta:
        proxy = True
        verbose_name = "案源报告"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


class KeHuYingJiXiangYing(Case):
    class Meta:
        proxy = True
        verbose_name = "客户应急响应报告"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


class QuzhengJiChuzhijianyi(Case):
    class Meta:
        proxy = True
        verbose_name = "取证及处置建议报告"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


class Notes(Case):
    class Meta:
        proxy = True
        verbose_name = "TBD Notes"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


# 5个OptionClass的共同基类, 因为展示字段 搜索字段 过滤字段 内联字段等有很多相同的部分
class BaseAdmin:
    list_display = ["name", "happen_datetime", "TLP", "tags", "len_ioc", "len_file", "update_user", "update_time"]
    search_fields = ["name", "TLP", "tags", "update_user"]
    list_filter = ["name", "happen_datetime", "TLP", "update_user", "update_time"]
    form = CaseForm

    # 在同一编辑界面,内联IOC编辑
    inlines = [IocInline, FileAttachmentInline]
    # 禁用导出功能
    list_export = []


class CaseAdmin(BaseAdmin):
    # 编辑时不显示某些字段
    exclude = ["report_type", "is_tdps", "update_user", "related_address", "related_consumer", "clue_source"]

    def save_models(self):
        # 每个model proxy保存的时候讲report_type设置成对应的类型
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "团伙分析报告"
        obj.save()

    def queryset(self):
        # 列表只展示report_type为对应的类型的结果集
        return self.model.objects.filter(report_type="团伙分析报告")


class AnYuanAdmin(BaseAdmin):
    exclude = ["report_type", "is_tdps", "update_user", "related_consumer", "clue_source"]

    def save_models(self):
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "案源报告"
        obj.save()

    def queryset(self):
        return self.model.objects.filter(report_type="案源报告")


class KeHuYingJiXiangYingAdmin(BaseAdmin):
    exclude = ["report_type", "is_tdps", "update_user", "related_address", "clue_source"]

    def save_models(self):
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "客户应急响应报告"
        obj.save()

    def queryset(self):
        return self.model.objects.filter(report_type="客户应急响应报告")


class QuzhengJiChuzhijianyiAdmin(BaseAdmin):
    exclude = ["report_type", "update_user", "related_address", "clue_source"]
    list_filter = ["name", "happen_datetime", "is_tdps", "TLP", "update_user", "update_time"]

    def save_models(self):
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "取证及处置建议报告"
        obj.save()

    def queryset(self):
        return self.model.objects.filter(report_type="取证及处置建议报告")


class NotesAdmin(BaseAdmin):
    list_display = ["name", "happen_datetime", "clue_source", "len_ioc", "len_file", "update_user", "update_time"]
    search_fields = ["name", "happen_datetime", "clue_source", "update_user"]
    list_filter = ["name", "happen_datetime", "update_user", "update_time"]
    exclude = ["report_type", "is_tdps", "update_user", "related_address", "related_consumer", "threat_level", "tags",
               "TLP"]

    def save_models(self):
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "TBD Notes"
        obj.save()

    def queryset(self):
        return self.model.objects.filter(report_type="TBD Notes")


# 将5个model proxy和对应的OptionClass注册到xadmin上
xadmin.site.register(TuanHuoFenXi, CaseAdmin)
xadmin.site.register(AnYuan, AnYuanAdmin)
xadmin.site.register(KeHuYingJiXiangYing, KeHuYingJiXiangYingAdmin)
xadmin.site.register(QuzhengJiChuzhijianyi, QuzhengJiChuzhijianyiAdmin)
xadmin.site.register(Notes, NotesAdmin)

```

效果图:

页面上有5个管理, 实际数据库在一张表里面. 只是report_type字段类型不同

![](http://img.azhangbaobao.cn/img/20190718133046.png)





### Q: 如何在xadmin自定义菜单, 自定义页面

### A:

1. 在xadmin.py，GlobalSettings中自定义菜单

2. 自定义视图函数，并获取原来的菜单等信息（主要是为了用xadmin的模板），具体的自己看xadmin源码

3. 在adminx.py中注册路由

4. html继承。

举例:

**xadmin.py:**

```python
class GlobalSetting:
    site_title = '微步后台管理'
    site_footer = '微步在线'

    # menu_style = 'accordion' # 设置app折叠
    def get_site_menu(self):
        return (
            {'title': '自定义菜单',
             'menus': (
                 {
                     'title': '自定义页面',
                     'url': '/admin/testview/',
                 },
             )
             },
        )
    # 需要设置权限的话
    # def get_site_menu(self):
    #     return (
    #         {'title': '原来model',
    #          'perm': self.get_model_perm(Case, 'view'),
    #          'menus': (
    #              {
    #                  'title': '新',
    #                  'url': '/admin/test_view2/',
    #                  # 'perm': self.get_model_perm(ZVipbalanceList, 'view'),
    #              },
    #          )
    #          },
    #     )
```

**views.py:**

```python
from xadmin.views import CommAdminView
from django.shortcuts import render


class TestView(CommAdminView):
    def get(self, request):
        context = super().get_context()
        title = "会员延期"
        # context["breadcrumbs"].append({'url': '/cwyadmin/', 'title': title})
        context["title"] = title
        context["context1"] = [1, 2, 3]
        return render(request, 'thehive/test.html', context)  # 主目录的 template下的 html文件
```

**thehive/test.html**

{% raw %}

```django
{% extends 'xadmin/base_site.html' %}
{# 例 展示本地文件内容#}
{% block nav_form %}
    <h3>{{ title }}</h3>
    {% for i in context1 %}
        <p>{{ i }}</p>
    {% endfor %}
{% endblock %}
```

{% endraw %}

**xadmin.py:**

```python
import xadmin
from .views import TestView
 
xadmin.site.register_view("testview/", TestView, name="testview")
```

