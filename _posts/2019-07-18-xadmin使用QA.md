---
title: xadmin使用Q&A
key: xadmin_qa
layout: article
date: '2019-07-18 12:51:00'
tags: 技术 python
typora-root-url: ../../iblog
---

### Q: 如何在一个model的新增或编辑页面里面内嵌另一个model的编辑页面

### A:

1. 定义一个Inline类
2. 在model的OptionClass里面讲Inline类注入到inlines属性里面

举例:

在IOC这个model里面内嵌了两个一对多的model. IOC和FileAttachment

**xadmin.py**

```python
from .models import Case, Ioc, FileAttachment
class IocInline:
    model = Ioc
    extra = 0

class FileAttachmentInline:
    model = FileAttachment
    extra = 0

class CaseForm(ModelForm):
  # 自定义widgets
    tags = SimpleArrayField(CharField(), widget=Select2Widget, required=False)
    
class CaseAdmin:
    list_display = ["name", "happen_datetime", "TLP", "tags", "len_ioc", "len_file", "update_user", "update_time"]
    search_fields = ["name", "TLP", "tags", "update_user"]
    list_filter = ["name", "happen_datetime", "TLP", "update_user", "update_time"]
    # 因为自定义了widgets 所以设置了form属性
    form = CaseForm

    # 在同一编辑界面,内联IOC编辑
    inlines = [IocInline, FileAttachmentInline]
    list_export = []
```

效果图: 

点击+ 即可新增多个

![](http://img.azhangbaobao.cn/img/20190718132851.png)

### Q: 如何使用一个数据库表, 但是使用多个xadmin页面

### A:

1. 搞清楚为什么有这样的需求, 原因是django的权限系统只能针对表级别的增删改查做. 但是实际开发中, 会出现一种需求, 都是一个model表, 但是里面有个类型字段不同, 操作的权限因而不同. 这就需要五个页面. 但是每个页面的查询实际上是model查询根据类型过滤之后的结果
2. django的model里面有个model proxy. 可以实现这一需求, model proxy不落实到数据库, 但是继承落实到数据库里的model. 实际上增删改查操作继承的model
3. 每个model proxy再定义自己的OptionClass
4. 将model proxy和 OptionClass注册到xadmin
5. 做makemigrations的时候django<2.2的时候有个bug. 就是model proxy生成的权限的Content Type不是model proxy, 而是继承的model的. 需要编写自定义command来修复这个bug.

举例:

```python
from .models import Case



## 定义了5个model proxy
class TuanHuoFenXi(Case):
    class Meta:
        proxy = True
        verbose_name = "团伙分析报告"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


class AnYuan(Case):
    class Meta:
        proxy = True
        verbose_name = "案源报告"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


class KeHuYingJiXiangYing(Case):
    class Meta:
        proxy = True
        verbose_name = "客户应急响应报告"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


class QuzhengJiChuzhijianyi(Case):
    class Meta:
        proxy = True
        verbose_name = "取证及处置建议报告"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


class Notes(Case):
    class Meta:
        proxy = True
        verbose_name = "TBD Notes"
        verbose_name_plural = verbose_name
        default_permissions = ('add', 'change', 'delete', 'view')


# 5个OptionClass的共同基类, 因为展示字段 搜索字段 过滤字段 内联字段等有很多相同的部分
class BaseAdmin:
    list_display = ["name", "happen_datetime", "TLP", "tags", "len_ioc", "len_file", "update_user", "update_time"]
    search_fields = ["name", "TLP", "tags", "update_user"]
    list_filter = ["name", "happen_datetime", "TLP", "update_user", "update_time"]
    form = CaseForm

    # 在同一编辑界面,内联IOC编辑
    inlines = [IocInline, FileAttachmentInline]
    # 禁用导出功能
    list_export = []


class CaseAdmin(BaseAdmin):
    # 编辑时不显示某些字段
    exclude = ["report_type", "is_tdps", "update_user", "related_address", "related_consumer", "clue_source"]

    def save_models(self):
        # 每个model proxy保存的时候讲report_type设置成对应的类型
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "团伙分析报告"
        obj.save()

    def queryset(self):
        # 列表只展示report_type为对应的类型的结果集
        return self.model.objects.filter(report_type="团伙分析报告")


class AnYuanAdmin(BaseAdmin):
    exclude = ["report_type", "is_tdps", "update_user", "related_consumer", "clue_source"]

    def save_models(self):
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "案源报告"
        obj.save()

    def queryset(self):
        return self.model.objects.filter(report_type="案源报告")


class KeHuYingJiXiangYingAdmin(BaseAdmin):
    exclude = ["report_type", "is_tdps", "update_user", "related_address", "clue_source"]

    def save_models(self):
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "客户应急响应报告"
        obj.save()

    def queryset(self):
        return self.model.objects.filter(report_type="客户应急响应报告")


class QuzhengJiChuzhijianyiAdmin(BaseAdmin):
    exclude = ["report_type", "update_user", "related_address", "clue_source"]
    list_filter = ["name", "happen_datetime", "is_tdps", "TLP", "update_user", "update_time"]

    def save_models(self):
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "取证及处置建议报告"
        obj.save()

    def queryset(self):
        return self.model.objects.filter(report_type="取证及处置建议报告")


class NotesAdmin(BaseAdmin):
    list_display = ["name", "happen_datetime", "clue_source", "len_ioc", "len_file", "update_user", "update_time"]
    search_fields = ["name", "happen_datetime", "clue_source", "update_user"]
    list_filter = ["name", "happen_datetime", "update_user", "update_time"]
    exclude = ["report_type", "is_tdps", "update_user", "related_address", "related_consumer", "threat_level", "tags",
               "TLP"]

    def save_models(self):
        obj = self.new_obj
        obj.update_user = self.user.username
        obj.report_type = "TBD Notes"
        obj.save()

    def queryset(self):
        return self.model.objects.filter(report_type="TBD Notes")


# 将5个model proxy和对应的OptionClass注册到xadmin上
xadmin.site.register(TuanHuoFenXi, CaseAdmin)
xadmin.site.register(AnYuan, AnYuanAdmin)
xadmin.site.register(KeHuYingJiXiangYing, KeHuYingJiXiangYingAdmin)
xadmin.site.register(QuzhengJiChuzhijianyi, QuzhengJiChuzhijianyiAdmin)
xadmin.site.register(Notes, NotesAdmin)

```

定义完之后需要执行`python manage.py makemigrations`和`pyhton manage.py migrate` 因为django在2.2版本之前, 有一个bug, model proxy生成的权限的content type是被继承的model, 而不是model proxy导致 赋给用户权限的时候不能正常使用.  但是xadmin目前不支持django 2.2, 最高支持到2.0.12, 所以使用办法在对应app目录下新建一个文件

![](http://img.azhangbaobao.cn/img/20190718141401.png)

**apps/thehive/management/commands/fix_permissions.py**

```python
# -*- coding: utf-8 -*-
__author__ = '陈章'
__date__ = '2019-07-17 18:17'
"""Add permissions for proxy model.
This is needed because of the bug https://code.djangoproject.com/ticket/11154
in Django (as of 1.6, it's not fixed).
When a permission is created for a proxy model, it actually creates if for it's
base model app_label (eg: for "article" instead of "about", for the About proxy
model).
What we need, however, is that the permission be created for the proxy model
itself, in order to have the proper entries displayed in the admin.
"""

import sys

from django.contrib.auth.management import _get_all_permissions
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType
from django.core.management.base import BaseCommand
from django.apps import apps
from django.utils.encoding import smart_text


class Command(BaseCommand):
    help = "Fix permissions for proxy models."

    def handle(self, *args, **options):
        for model in apps.get_models():
            opts = model._meta
            # breakpoint()
            ctype, created = ContentType.objects.get_or_create(
                app_label=opts.app_label,
                model=opts.object_name.lower())

            for codename, name in _get_all_permissions(opts):
                p, created = Permission.objects.get_or_create(
                    codename=codename,
                    content_type=ctype,
                    defaults={'name': name})
                if created:
                    sys.stdout.write('Adding permission {}\n'.format(p))
```

之后执行`python manage.py fix_permissions` 就会把5个model proxy的权限增加到数据库.

但是这里还有一个小坑. 默认增加的权限是增删改, 因为`get_all_permissions(opts)`返回的只有增删改,没有查. 解决办法是在model proxy的class Meta里增加字段`default_permissions = ('add', 'change', 'delete', 'view')`.

**adminx.py**

```python
class QuzhengJiChuzhijianyi(Case):
    class Meta:
        proxy = True
        verbose_name = "取证及处置建议报告"
        verbose_name_plural = verbose_name
        # 增加default_permissions 覆盖掉django默认的权限只有增删改
        default_permissions = ('add', 'change', 'delete', 'view')
```

执行完`python manage.py makemigrations` `pyhton manage.py migrate` `python manage.py fix_permissions`之后, 即可正常使用了.

效果图:

页面上有5个管理, 实际数据库在一张表里面. 只是report_type字段类型不同

![](http://img.azhangbaobao.cn/img/20190718133046.png)



### Q: 如何自定义字段在页面上的显示效果. 比如使用自己特定的js控件

### A:

1. 可以自定义widgets
2. 自定义form将widgets设置到form的对应的field上
3. 在OptionClass里设置form
4. 将OptionClass设置到xadmin上

举例:

在页面上显示tags字段时候想使用select2.js这个模板来实现这样的效果. 也就是多选的select框, 选中的放在上面作为标签, 可以叉掉.

![](http://img.azhangbaobao.cn/img/20190718135838.png)

**models.py**

首先models.py里面tags字段使用了postgres才有的ArrayField来存储多个选项

```python
from django.contrib.postgres.fields import ArrayField
from django.db import models

class Case(models.Model):
    tags = ArrayField(models.CharField(max_length=200), null=True, blank=True)
```

**widgets.py**  

要将前端接收到的tags[]字段修改成tag才能保存

```python
import os

import pandas as pd
from django import forms
from django.utils.safestring import mark_safe

pwd = os.path.abspath(os.path.dirname(__file__))

# 加载tag标签的所有值
df = pd.read_csv(os.path.join(pwd, "hunting_rules_db.tags_list.csv"))
tags_list = list(df["name"].values)

# 要注入到页面上的js
JS = '''
<link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.7/css/select2.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.7/js/select2.min.js"></script>
<script>
    $(function () {
        $('.js-example-basic-multiple').select2();
    });
</script>
'''


class Select2Widget(forms.SelectMultiple):
    # 要处理多选的字段
    array_field_list = ['tags']

    def value_from_datadict(self, data, files, name):
        """
        处理前端是tags[]后端tag
        :param data:
        :param files:
        :param name:
        :return:
        """
        if name in self.array_field_list:
            name += '[]'
        try:
            getter = data.getlist
        except AttributeError:
            getter = data.get
        return getter(name)

    def render(self, name, value, attrs=None, renderer=None):
        '''
        关键方法
        :param name:
        :param value:
        :param attrs:
        :return:
        '''
        output = [JS]
        output.append('<select class="js-example-basic-multiple" name="tags[]" multiple="multiple">')
        tags_list = self.get_tags_list()
        if value is None:
            value = []
        for tag in tags_list:
            if tag in value:
                selected = ' selected="selected"'
            else:
                selected = ''
            output.append(f'<option value="{tag}" {selected}>{tag}</option>')
        output.append('</select>')

        return mark_safe('\n'.join(output))

    def get_tags_list(self):
        return tags_list
```

**adminx.py**

```python
from django.contrib.postgres.forms import SimpleArrayField
from django.forms import ModelForm, CharField

import xadmin
from xadmin import views
from .models import Case, Ioc, FileAttachment
from .widgets import Select2Widget

#tags注册到form中
class CaseForm(ModelForm):
    tags = SimpleArrayField(CharField(), widget=Select2Widget, required=False)

# form注册到OptionClass中
class BaseAdmin:
    list_display = ["name", "happen_datetime", "TLP", "tags", "len_ioc", "len_file", "update_user", "update_time"]
    form = CaseForm
```



### Q: 如何在xadmin自定义菜单, 自定义页面

### A:

1. 在xadmin.py，GlobalSettings中自定义菜单

2. 自定义视图函数，并获取原来的菜单等信息（主要是为了用xadmin的模板），具体的自己看xadmin源码

3. 在adminx.py中注册路由

4. html继承。

举例:

**xadmin.py:**

```python
class GlobalSetting:
    site_title = '微步后台管理'
    site_footer = '微步在线'

    # menu_style = 'accordion' # 设置app折叠
    def get_site_menu(self):
        return (
            {'title': '自定义菜单',
             'menus': (
                 {
                     'title': '自定义页面',
                     'url': '/admin/testview/',
                 },
             )
             },
        )
    # 需要设置权限的话
    # def get_site_menu(self):
    #     return (
    #         {'title': '原来model',
    #          'perm': self.get_model_perm(Case, 'view'),
    #          'menus': (
    #              {
    #                  'title': '新',
    #                  'url': '/admin/test_view2/',
    #                  # 'perm': self.get_model_perm(ZVipbalanceList, 'view'),
    #              },
    #          )
    #          },
    #     )
```

**views.py:**

```python
from xadmin.views import CommAdminView
from django.shortcuts import render


class TestView(CommAdminView):
    def get(self, request):
        context = super().get_context()
        title = "会员延期"
        # context["breadcrumbs"].append({'url': '/cwyadmin/', 'title': title})
        context["title"] = title
        context["context1"] = [1, 2, 3]
        return render(request, 'thehive/test.html', context)  # 主目录的 template下的 html文件
```

**thehive/test.html**

{% raw %}

```django
{% extends 'xadmin/base_site.html' %}
{# 例 展示本地文件内容#}
{% block nav_form %}
    <h3>{{ title }}</h3>
    {% for i in context1 %}
        <p>{{ i }}</p>
    {% endfor %}
{% endblock %}
```

{% endraw %}

**xadmin.py:**

```python
import xadmin
from .views import TestView
 
xadmin.site.register_view("testview/", TestView, name="testview")
```

